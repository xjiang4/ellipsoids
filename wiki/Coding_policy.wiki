#summary Coding policy introduces a naming convention for variables,classes,functions and some other generic requirements that every developer should follow.
#labels Phase-Requirements

= Introduction =

Coding policy consists of 
  # Naming/style convention
  # Enforces test-driven development
  # Some other generic requirements that in long-term make a life of every developer easier.

= Generic requirements =

Use English as the only language of communication. Source code comments, documentation etc. should be in English. Russian or other languages cannot be used here.

= Naming and style convention =

Every developer should follow the following naming and style convention:
[http://ellipsoids.googlecode.com/svn/wiki/attachments/matlabstylereq/matlabstylereq.pdf Matlab naming convention]

= Test-driven approach =
Always follow a test driven approach. To understand what the test-driven approach is please read about [http://ellipsoids.googlecode.com/svn/wiki/attachments/TheWayOfTestivus.pdf Unit testing karma].

More specifically, you should comply with the following rules.

   # Every new feature should be complemented with a test that makes sure that the feature is implemented correctly
   # Before committing any changes make sure that you do not break existing tests.
   # Use MLUNITEXT as a unit-testing framework for your tests. See [MLUNITEXT_unit_testing_framework_description MLUNITEXT framework description].
   # If you put class MyClass into package 'mypackage.mychildpackage' then your tests should be in `mypackage.mychildpackage.test.mlunit' while 'run_tests' function should be in `mypackage.mychildpackage.test` i.e. its full name should be `mypackage.mychildpackage.test.run_tests`.
   # Write higher-level `run_tests` function (`mypackage.test.run_test` that calls `mypackage.mychildpackage.test.run_tests`)
= Program as Matlab were a statically-typified language. Fix and check input argument types =
   # Do not write classes/functions that can accept arguments of completely different types. The following example shows the construction that *every developer should avoid!!*
  {{{
  function result=myfunc(a)
  if iscell(a)
     result=a{1}+1;
  elseif isnumeric(a)
     result=a+1;
  end 
  }}}
   # Check input argument types using `modgen.common.type.simple.checkgen` and `modgen.common.type.simple.checkgenext` functions:
{{{
%check whether a condition numel(x1)==numel(x2) holds for variables  aVar and bVar
%throw exception if it does not, in exception refer to the variables as 'Alpha' and 'Beta' 
modgen.common.type.simple.checkgenext('numel(x1)==numel(x2)',2,aVar,bVar,'Alpha')
%
%do the same but determine the variable names automatically
modgen.common.type.simple.checkgenext('numel(x1)==numel(x2)',2,aVar,bVar)
%
%automatic variable name recognition does not work properly if you use something like that
modgen.common.type.simple.checkgenext('numel(x1)==numel(x2)',varargin{1},vaarargin{2})
%
%simpler variant just for 1 variable
modgen.common.type.simple.checkgenext(aVar,'isnumeric(x)&&isa(x,'int32')||isscalar(x)')
}}}
   # Parse input argument and check their types using `modgen.common.parseparext` function (see the following example). The main purpose of `parseparext` is to parse input arguments (properties and regular inputs) but it also can check for simple conditions that do not involve multiple variables. For checking the more complex conditiosn like `numel(x1)==numel(x2)` use `checkgenext` function mentioned above. For more infromation about `modgen.common.parseparext` read its help header within the function itself. For simple inputs a more light-weight function `modgen.common.parseparams` can be used (it is different from Matlab built-in `parseparams` function).
  {{{
  [reg,isSpecVec,...
      propVal1,propVal2,propVal3...
      isPropVal1,isPropVal2,isPropVal3]=...
      modgen.common.parseparext({1,2,'prop1',3,'prop2',4},...
      {'prop1','prop2','prop3';...
      [],[],5;...
      'isscalar(x)','isscalar(x)','isnumeric(x)'},...
      [0 3],...
      'regDefList',{1,2,3},...
      'regCheckList',{'isnumeric(x)','isscalar(x)','isnumeric(x)'},...
      'isObligatoryPropVec',[true true false])
      %This will produce
      %reg =   {1,2,3}
      %isSpecVec = [true,true,false]
      %propVal1 = 3
      %propVal2 = 4
      %propVal3 = 5
      %isPropVal1 =true
      %isPropVal2 =true
      %isPropVal3 =false
  }}} 

= Use special functions to throw errors and warnings =
Use `modgen.common.throwerror` and `modgen.common.throwwarn` functions to throw warnings. Do not use `error` and `warning` functions directly. For more information read the help headers for these functions.

= Use exceptions only for exceptional situations =
The following example demonstrates an extremely improper use of exceptions that *every developer should avoid !!*
{{{
function isPositive=issizeequal(aVec,bVec)
aVec=[1,2,3];
bVec=[1,2];
try
    aVec==bVec;
catch meObj
    if strcmp(meObj.identifier,'MATLAB:dimagree')
        isPositive=false;
    else
        rethrow(meObj);
    end
end
}}}
= Use logging to make debugging easier =
Use logging to make debugging easier. For logging use `modgen.logging.log4j.Log4jConfigurator` class. The following example demonstrates its use.
  {{{
   import modgen.logging.log4j.Log4jConfigurator;
   logger=Log4jConfigurator.getLogger();
   logger.info('doing something useful...');
   a=2*2;
   logger.info('doing something useful: done');
  }}}

= Put your code into well-structured packages =
Do not put everything into a single package unless the classes/functions are tightly-related.