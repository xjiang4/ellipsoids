function [tout,yout,dyRegMat] = odeAdamsreg(fOdeDeriv,fOdeReg,tspan,y0,...
    options,varargin)

% ODEADAMSREG is an extension of Adams method capable of solving ODEs
% with right hand-side functions having a limited defenition area
%
% Input:
%   regular:
%       fOdeDeriv: function_handle[1,1] - function responsible for
%           calculating the right-hand side function as f=fOdeDeriv(t,y)
%       fOdeReg: function_handle[1,1] - function responsible for
%           regularizing the phase variables as
%           [isStrictViolation,yReg]=fOdeReg(fOdeDeriv, tTime, yTime, regTime) where isStrictViolation
%           is supposed to be true when y is outside of definition area of
%           the right-hand side function.
%           yTime is a vector of 3 last values of y, regTime is a vector of
%           2 last values of yReg
%       tspan: double[1,2]/double[1,nPoints] time range, same meaning 
%           as in ode45
%       y0: double[1,nDims] - initial state, same meaning as in ode45
%       
%   optional:
%       options: odeset[1,1] - options generated by odeset function, same
%           meaning as in ode45
%
%   properties:
%       regMaxStepTol: double[1,1] - maximum allowed regularization size
%           calculated as max(abs(yReg-y)) allowed per step
%       regAbsTol: double[1,1] - maximum regularization tolerance
%           calculated as max(abs(yReg-y)) that is allowed to consider the
%           integration step to be successful. If the tolerance level is
%           not achieved the regularization continues in the iterative
%           manner via correcting dyReg or decreasing the step size
%       nMaxRegSteps: double[1,1] - maximum number of allowed
%           regularization steps, if regAbsTol is not achieved in 
%           nMaxRegSteps(or less) the integration process fails
%
% Output:
%   tout: double[nPoints,1] - time grid, same meaning as in ode45
%   yout: double[nPoints,nDims] - solution, same meaning as in ode45
%   dyRegMat: double[nPoints,nDims] - regularizing derivative addition
%       to the right-hand side function value performed at each step,
%       basically yout is a solution of dot(y)=fOdeDeriv(t,y)+dyRegMat(t,y)
%
% $Author: Vadim Kaushanskiy  <vkaushanskiy@gmail.com> $	$Date: 3-November 2012$
% $Copyright: Moscow State University,
%            Faculty of Computational Mathematics and Cybernetics,
%            System Analysis Department 2012 $
%
import modgen.common.throwerror;
import modgen.common.type.simple.*;
solver_name = 'odeAdamsreg';

%% Constants
N_MAX_REG_STEPS_DEFAULT=3;
N_PROGRESS_DOTS_SHOWN=10;


%% Check inputs
if nargin < 4
    options = [];
    if nargin < 3
        throwerror('wrongInput','not enough input arguments');
    end
end


[opts,~,regMaxStepTol,regAbsTol,nMaxRegSteps,isRegMaxStepTolSpec,...
    isRegAbsTolSpec]=modgen.common.parseparext(varargin,...
    {'regMaxStepTol','regAbsTol','nMaxRegSteps';...
    [],[],N_MAX_REG_STEPS_DEFAULT;...
    'isnumeric(x)','isnumeric(x)','isnumeric(x)'});
options=odeset(options,opts{:});



%% There might be no output requested...
checkgen(fOdeDeriv,'isfunction(x)');
checkgen(fOdeReg,'isfunction(x)');
%

%% Handle solver arguments
[neq, tspan, ntspan, next, t0, tfinal, y0, f0, ...
    options, threshold, rtol, normcontrol, normy, hmax, htry, htspan,...
    dataType,absTol] = ...
    odearguments(solver_name,fOdeDeriv, tspan, y0, options);
if ~isRegMaxStepTolSpec
    regMaxStepTol=absTol*10;
end
if ~isRegAbsTolSpec
    regAbsTol=256*eps(dataType);
end

prDispObj=gras.gen.ProgressCmdDisplayer(t0,tfinal,...
    N_PROGRESS_DOTS_SHOWN,modgen.common.getcallername());
prDispObj.start();


%% Handle the output
refine = max(1,odeget(options,'Refine',4,'fast'));
if ntspan > 2
    outputAt = 'RequestedPoints';         % output only at tspan points
elseif refine <= 1
    outputAt = 'SolverSteps';             % computed points, no refinement
else
    outputAt = 'RefinedSteps';            % computed points, with refinement
    S = (1:refine-1) / refine;
end
%
t = t0;
y = y0;


if ntspan > 2                         % output only at tspan points
    tout = zeros(1,ntspan,dataType);
    yout = zeros(ntspan, neq, dataType);
    dyRegMat=yout;
else                                  % alloc in chunks
    chunk = min(max(100,50*refine), refine+floor((2^13)/neq));
    tout = zeros(1,chunk,dataType);
    yout = zeros(neq,chunk,dataType);
    dyRegMat=yout;
end


%% Allocate memory for the output.
if ntspan > 2                         % output only at tspan points
    tout = tspan;
    yout = zeros(neq, ntspan,dataType);
    dyRegMat=yout;
else                                  % alloc in chunks
    chunk = min(max(100,50*refine), refine+floor((2^13)/neq));
    tout = linspace(tspan(1), tspan(2), chunk);
    yout = zeros(neq, chunk, dataType);
    dyRegMat=yout;
end
%nout = 1;
%tout(nout) = t;
%yout(:,nout) = y;



%% THE MAIN LOOP

isDone = false;
step = 0;
while (~isDone)
    step = step + 1

    [toutStart, youtStart] = runge_kutt(fOdeDeriv, tout(1), tout(3), y0, 2, size(yout, 1));
    yout(:, 1) = y0;
    yout(:, 2) = youtStart(:, 2);
    yout(:, 3) = youtStart(:, 3);

    hStep = tout(2) - tout(1);

    for iTime = 4:ntspan
        yout(:, iTime) = yout(:, iTime - 1) + hStep*(23*(fOdeDeriv(tout(iTime-1), yout(:, iTime-1)) + dyRegMat(:, iTime-1)) - ...
            16*(fOdeDeriv(tout(iTime-2), yout(:, iTime-2)) + dyRegMat(:, iTime-2)) + 5*(fOdeDeriv(tout(iTime-3), yout(:, iTime-3)) + dyRegMat(:, iTime-3)))./12; 
        [isReg, yy, yReg] = fOdeReg(fOdeDeriv, tout(iTime-3:iTime), yout(:, iTime-3:iTime), dyRegMat(:, iTime-3:iTime-2));
        if (isReg)
            yout(:, iTime) = yy;
            dyRegMat(:, iTime - 1) = yReg;
        end;
    end;
    if (step > 1)
        epsTol = norm(abs(yout(:, 1:2:end) - prevY(:, 1:end)), Inf)
        if (epsTol < regMaxStepTol)
            isDone = true;
        end;
    end;
    prevY = yout;
    hStep = hStep / 2;
    ntspan = ntspan*2;
    if (step >= 8)
        break;
    end;
    if (~isDone)
        tout = linspace(tout(1), tout(end) + hStep, ntspan)';
        yout = zeros(size(yout, 1), 2*size(yout, 2));
        dyRegMat = zeros(size(yout, 1), size(yout, 2));
    end;
end;


tout = tout(1:2^(step - 1):end);
yout = yout(:, 1:2^(step - 1):end);
dyRegMat = dyRegMat(:, 1:2^(step - 1):end);
end

function [t, x] = runge_kutt(f, t0, t1, x0, n, num)
    h = (t1 - t0) / n;
    x = zeros(num, n + 1);
    t = linspace(t0, t1, n + 1);
    x(:, 1) = x0;
    for i = 1:n
        k1 = h*f(t(i), x(:, i));
        k2 = h*f(t(i) + h / 2, x(:, i) + k1 / 2);
        k3 = h*f(t(i) + h / 2, x(:, i) + k2 / 2);
        k4 = h*f(t(i) + h, x(:, i) + k3);
       
        x(:, i + 1) = x(:, i) + (k1 + 2*k2 + 2*k3 + k4) ./ 6;
    end;
end
